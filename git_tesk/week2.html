<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 要求一：函式與流程控制
        function calculate(min,max){
            let sum = 0;
            for(let i = min; i < max + 1; i++){
                sum += i;
            }
            return sum;
        }
        console.log(calculate(1,3));
        console.log(calculate(4,8));

        // 要求二：JavaScript 物件與陣列
        function avg(data){
            let sum_salary = 0;
            data.employees.forEach(person =>{
                sum_salary += person.salary;
            })
            avg_salary = sum_salary / data['employees'].length; // 如果員工陣列增加但 count 忘記改
            //avg_salary = sum_salary / data['count']; // 如果員工陣列增加，且員工人數有同步修改
            return avg_salary;
        }
        avr_result = avg({
                "count":3,
                "employees":[
                    {
                        "name":"John",
                        "salary":30000
                    },
                    {
                        "name":"Bob",
                        "salary":60000
                    },
                    {
                        "name":"Jenny",
                        "salary":50000
                    }
                ]
        });
        console.log(avr_result);

        // 要求三：演算法
        // 想法：讓陣列進行排序，如果陣列的最後一個元素不是 0 則最後兩個元素相乘就是最大，如果陣列最後一個元素是 0 則前面兩個相乘最大
        function maxProduct(nums){
            if (nums.length < 2) return;

            let total = nums.length - 1;
            while(total > 0){
                for (let i = 0; i < total; i++){
                let tempVar = nums[i];
                    if(nums[i] > nums[i+1]){
                        nums[i] = nums[i+1];
                        nums[i+1] = tempVar;
                    }
                }
                total--;
            }
            if(nums[nums.length-1] === 0){
                return nums[0] * nums[1];
            }else{
                return nums[nums.length-1] * nums[nums.length-2];
            }
        }

        console.log(maxProduct([5, 20, 2, 6]));
        console.log(maxProduct([10, -20, 0, 3]));
        console.log(maxProduct([-1, 2]));
        console.log(maxProduct([-1, 0, 2]));
        console.log(maxProduct([-1, -2, 0])) ;

        // 要求四 ( 請閱讀英文 )：演算法
        // 想法：如果 target - 目標元素在陣列之中就回傳元素位置，為了避免找到同一個元素，所以設定 nums[i] = 'nan';
        function twoSum(nums,target){
            let target_left;
                for(let i = 0; i < nums.length; i++){
                    target_left = target - nums[i];
                    nums[i] = 'nan';
                    if (nums.includes(target_left)){
                        return [i,nums.indexOf(target_left)];
                    }
                }
        }
        console.log(twoSum([2,11,7,15],9));
        //console.log(twoSum([1, 6, 4, 5, 3, 3], 7));
        //console.log(twoSum([3, 2, 4], 6));
        //console.log(twoSum([3, 3], 6));

        // 要求五 ( Optional )：演算法
        // 想法：判斷元素是不是 0 ，如果是 0 則累加 0 出現的次數，如果是 1 表示中斷則將累加歸零
        function maxZeros(nums){
            let maxLengthArr = [];
            let maxLength = 0;

            for(let i = 0; i < nums.length; i++){
                    if(nums[i] === 0){
                        if(i === nums.length-1){
                            maxLength++;
                            maxLengthArr.push(maxLength);
                        }else{
                            maxLength++;
                        }
                    }else if(nums[i] === 1){
                        maxLengthArr.push(maxLength);
                        maxLength = 0;
                    }
            }
            return Math.max.apply(null,maxLengthArr);
        }
        console.log(maxZeros([0, 1, 0, 0]));
        console.log(maxZeros([1, 0, 0, 0, 0, 1, 0, 1, 0, 0]));
        console.log(maxZeros([1, 1, 1, 1, 1]));
        console.log(maxZeros([0, 0, 0, 1, 1]));
    </script>
</body>
</html>